package com.kira.malware.controllers;

import android.os.NetworkOnMainThreadException;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.kira.malware.models.LogModel;

import java.io.IOException;
import java.util.Map;

import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;

import org.json.JSONObject;

public class WebController {

    private static LogModel status;

    /**
     * Send a single HTTP GET request.
     */
    private static LogModel directGET(@NonNull String url, @Nullable Map<String, String> headers) {
        LogModel status = new LogModel();
        Response response = null;
        ResponseBody body = null;
        try {
            Request.Builder request = new Request.Builder();
            if (headers != null) {
                for (Map.Entry<String, String> header : headers.entrySet()) {
                    request.addHeader(header.getKey(), header.getValue());
                }
            }
            response = new OkHttpClient().newCall(request.url(url).get().build()).execute();
            if (!response.isSuccessful()) {
                status.setErrorMessage(String.format("%s: %s", response.code(), url));
            } else {
                status.setSuccess(true);
                status.setSuccessMessage(String.format("%s: %s", response.code(), url));
                body = response.body();
                if (body != null) {
                    status.appendInfoMessage("---------- RESPONSE BEGIN ----------");
                    status.appendMessage(body.string());
                }
            }
        } catch (IOException e) {
            status.setExceptionMessage(e.getMessage());
        } catch (NetworkOnMainThreadException ignored) {
            status.setExceptionMessage("Cannot perform a networking operation on the main thread");
        } finally {
            if (body != null) {
                body.close();
            }
            if (response != null) {
                response.close();
            }
        }
        return status;
    }

    /**
     * Send a single HTTP POST request.
     */
    private static LogModel directPOST(@NonNull String url, @Nullable Map<String, String> headers, @Nullable JSONObject payload, @Nullable String mediaType) {
        LogModel status = new LogModel();
        Response response = null;
        ResponseBody body = null;
        try {
            Request.Builder request = new Request.Builder();
            if (headers != null) {
                for (Map.Entry<String, String> header : headers.entrySet()) {
                    request.addHeader(header.getKey(), header.getValue());
                }
            }
            RequestBody data = payload != null && mediaType != null ? RequestBody.create(payload.toString(), MediaType.parse(mediaType)) : RequestBody.create(new byte[]{}, null);
            response = new OkHttpClient().newCall(request.url(url).post(data).build()).execute();
            if (!response.isSuccessful()) {
                status.setErrorMessage(String.format("%s: %s", response.code(), url));
            } else {
                status.setSuccess(true);
                status.setSuccessMessage(String.format("%s: %s", response.code(), url));
                body = response.body();
                if (body != null) {
                    status.appendInfoMessage("---------- RESPONSE BEGIN ----------");
                    status.appendMessage(body.string());
                }
            }
        } catch (IOException e) {
            status.setExceptionMessage(e.getMessage());
        } catch (NetworkOnMainThreadException ignored) {
            status.setExceptionMessage("Cannot perform a networking operation on the main thread");
        } finally {
            if (body != null) {
                body.close();
            }
            if (response != null) {
                response.close();
            }
        }
        return status;
    }

    /**
     * Send a single HTTP GET request in a new thread.
     */
    public static LogModel get(@NonNull String url, @Nullable Map<String, String> headers) {
        status = new LogModel();
        try {
            Thread thread = new Thread(() -> {
                LogModel tmp = directGET(url, headers);
                status.setSuccess(tmp.getSuccess());
                status.setMessage(tmp.getMessage());
            });
            thread.start();
            thread.join();
        } catch (InterruptedException e) {
            status.setSuccess(false);
            status.setExceptionMessage(e.getMessage());
        }
        return status;
    }

    /**
     * Send a single HTTP POST request in a new thread.
     */
    public static LogModel post(@NonNull String url, @Nullable Map<String, String> headers, @Nullable JSONObject payload, @Nullable String mediaType) {
        status = new LogModel();
        try {
            Thread thread = new Thread(() -> {
                LogModel tmp = directPOST(url, headers, payload, mediaType);
                status.setSuccess(tmp.getSuccess());
                status.setMessage(tmp.getMessage());
            });
            thread.start();
            thread.join();
        } catch (InterruptedException e) {
            status.setSuccess(false);
            status.setExceptionMessage(e.getMessage());
        }
        return status;
    }

    /**
     * Perform a series of HTTP requests in a new thread. Intended for demonstration purposes.
     */
    public static LogModel exploit() {
        status = new LogModel();
        try {
            Thread thread = new Thread(() -> {
                LogModel tmp;

                tmp = directGET("https://github.com", null);
                status.setSuccess(tmp.getSuccess());
                status.appendMessage(tmp.getMessage());


                tmp = directGET("https://github.com/ivan-sincek", null);
                status.setSuccess(tmp.getSuccess());
                status.appendMessage(tmp.getMessage());
            });
            thread.start();
            thread.join();
        } catch (InterruptedException e) {
            status.setSuccess(false);
            status.appendExceptionMessage(e.getMessage());
        }
        return status;
    }

}